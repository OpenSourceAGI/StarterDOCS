{"version":3,"sources":["turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/router-reducer-types.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/app-router-headers.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/is-thenable.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/use-action-queue.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/app-call-server.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/app-find-source-map-url.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/flight-data-helpers.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/app-build-id.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/hash.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/router/utils/cache-busting-search-param.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/set-cache-busting-search-param.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/fetch-server-response.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/unresolved-thenable.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/navigation-untracked.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/http-access-fallback/http-access-fallback.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/redirect-status-code.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/redirect-error.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/is-next-router-error.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/create-href-from-url.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/nav-failure-handler.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/handle-isr-error.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/error-boundary.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/match-segments.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/router/utils/handle-smooth-scroll.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/reducers/get-segment-value.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/segment.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/redirect.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/not-found.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/forbidden.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/unauthorized.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/unstable-rethrow.browser.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/dynamic-rendering-utils.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/lib/router-utils/is-postpone.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/hooks-server-context.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/static-generation-bailout.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/lib/metadata/metadata-constants.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/lib/scheduler.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/app-render/dynamic-rendering.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/unstable-rethrow.server.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/unstable-rethrow.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/navigation.react-server.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/bailout-to-client-rendering.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/navigation.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/redirect-boundary.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/utils/warn-once.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/http-access-fallback/error-boundary.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/create-router-cache-key.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/router/utils/app-paths.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/router/utils/interception-routes.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/bfcache.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/layout-router.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/render-from-template-context.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/invariant-error.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/shared/lib/utils/reflect-utils.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/request/search-params.browser.prod.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/request/search-params.browser.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/request/params.browser.prod.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/request/params.browser.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/web/spec-extension/adapters/reflect.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/create-deduped-by-callsite-server-error-logger.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/request/utils.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/request/search-params.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/server/request/params.ts","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/client-page.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/client-segment.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/lib/metadata/generate/icon-mark.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/metadata/async-metadata.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/global-error.tsx","turbopack:///[project]/docs-fuma/node_modules/next/dist/src/client/components/metadata/metadata-boundary.tsx"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","export const RSC_HEADER = 'RSC' as const\nexport const ACTION_HEADER = 'Next-Action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change Next-Router-State-Tree to be a segment path, we can use\n// that instead. Then Next-Router-Prefetch and Next-Router-Segment-Prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'Next-Router-Segment-Prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'Next-Url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  return isThenable(state) ? use(state) : state\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../server/app-render/types'\nimport type { HeadData } from '../shared/lib/app-router-context.shared-runtime'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map(getFlightDataPartsFromPath)\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: string | string[] | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string | null {\n  if (\n    prefetchHeader === undefined &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return null\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  if (uniqueCacheKey === null) {\n    // None of our custom request headers are present. We don't need to set a\n    // cache-busting search param.\n    return\n  }\n\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  pairs.push(`${NEXT_RSC_UNION_QUERY}=${uniqueCacheKey}`)\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client'\n\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      (require('react-server-dom-webpack/client.edge') as typeof import('react-server-dom-webpack/client.edge'))\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      (require('react-server-dom-webpack/client') as typeof import('react-server-dom-webpack/client'))\n) as typeof import('react-server-dom-webpack/client')\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\nexport type FetchServerResponseResult = {\n  flightData: NormalizedFlightData[] | string\n  canonicalUrl: URL | undefined\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n}\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n}\n\nexport function urlToUrlWithoutFlightMarker(url: string): URL {\n  const urlWithoutFlightParameters = new URL(url, location.origin)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return {\n    flightData: urlToUrlWithoutFlightMarker(url).toString(),\n    canonicalUrl: undefined,\n    couldBeIntercepted: false,\n    prerendered: false,\n    postponed: false,\n    staleTime: -1,\n  }\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(\n      JSON.stringify(flightRouterState)\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    const res = await createFetch(\n      url,\n      headers,\n      fetchPriority,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(res.url)\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const flightStream = postponed\n      ? createUnclosingPrefetchStream(res.body)\n      : res.body\n    const response = await (createFromNextReadableStream(\n      flightStream\n    ) as Promise<NavigationFlightResponse>)\n\n    if (getAppBuildId() !== response.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    return {\n      flightData: normalizeFlightData(response.f),\n      canonicalUrl: canonicalUrl,\n      couldBeIntercepted: interception,\n      prerendered: response.S,\n      postponed,\n      staleTime,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return {\n      flightData: url.toString(),\n      canonicalUrl: undefined,\n      couldBeIntercepted: false,\n      prerendered: false,\n      postponed: false,\n      staleTime: -1,\n    }\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n}\n\nexport async function createFetch(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  signal?: AbortSignal\n): Promise<RSCResponse> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let browserResponse = await fetch(fetchUrl, fetchOptions)\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid — when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      browserResponse = await fetch(fetchUrl, fetchOptions)\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<unknown> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n","import { useContext } from 'react'\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * This checks to see if the current render has any unknown route parameters.\n * It's used to trigger a different render path in the error boundary.\n *\n * @returns true if there are any unknown route parameters, false otherwise\n */\nfunction hasFallbackRouteParams() {\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) return false\n\n    const { fallbackRouteParams } = workStore\n    if (!fallbackRouteParams || fallbackRouteParams.size === 0) return false\n\n    return true\n  }\n\n  return false\n}\n\n/**\n * This returns a `null` value if there are any unknown route parameters, and\n * otherwise returns the pathname from the context. This is an alternative to\n * `usePathname` that is used in the error boundary to avoid rendering the\n * error boundary when there are unknown route parameters. This doesn't throw\n * when accessed with unknown route parameters.\n *\n * @returns\n *\n * @internal\n */\nexport function useUntrackedPathname(): string | null {\n  // If there are any unknown route parameters we would typically throw\n  // an error, but this internal method allows us to return a null value instead\n  // for components that do not propagate the pathname to the static shell (like\n  // the error boundary).\n  if (hasFallbackRouteParams()) {\n    return null\n  }\n\n  // This shouldn't cause any issues related to conditional rendering because\n  // the environment will be consistent for the render.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useContext(PathnameContext)\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n","import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import { useEffect } from 'react'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\n\nexport function handleHardNavError(error: unknown): boolean {\n  if (\n    error &&\n    typeof window !== 'undefined' &&\n    window.next.__pendingUrl &&\n    createHrefFromUrl(new URL(window.location.href)) !==\n      createHrefFromUrl(window.next.__pendingUrl)\n  ) {\n    console.error(\n      `Error occurred during navigation, falling back to hard navigation`,\n      error\n    )\n    window.location.href = window.next.__pendingUrl.toString()\n    return true\n  }\n  return false\n}\n\nexport function useNavFailureHandler() {\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    // this if is only for DCE of the feature flag not conditional\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      const uncaughtExceptionHandler = (\n        evt: ErrorEvent | PromiseRejectionEvent\n      ) => {\n        const error = 'reason' in evt ? evt.reason : evt.error\n        // if we have an unhandled exception/rejection during\n        // a navigation we fall back to a hard navigation to\n        // attempt recovering to a good state\n        handleHardNavError(error)\n      }\n      window.addEventListener('unhandledrejection', uncaughtExceptionHandler)\n      window.addEventListener('error', uncaughtExceptionHandler)\n      return () => {\n        window.removeEventListener('error', uncaughtExceptionHandler)\n        window.removeEventListener(\n          'unhandledrejection',\n          uncaughtExceptionHandler\n        )\n      }\n    }, [])\n  }\n}\n","const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isRevalidate || store?.isStaticGeneration) {\n      console.error(error)\n      throw error\n    }\n  }\n\n  return null\n}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    if (this.state.error) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n","import type { Segment } from '../../server/app-render/types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */\nexport function handleSmoothScroll(\n  fn: () => void,\n  options: { dontForceLayout?: boolean; onlyHashChange?: boolean } = {}\n) {\n  // if only the hash is changed, we don't need to disable smooth scrolling\n  // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n  if (options.onlyHashChange) {\n    fn()\n    return\n  }\n  const htmlElement = document.documentElement\n  const existing = htmlElement.style.scrollBehavior\n  htmlElement.style.scrollBehavior = 'auto'\n  if (!options.dontForceLayout) {\n    // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n    // Otherwise it will not pickup the change in scrollBehavior\n    // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n    htmlElement.getClientRects()\n  }\n  fn()\n  htmlElement.style.scrollBehavior = existing\n}\n","import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n","import type { Segment } from '../../server/app-render/types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n","const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')\n\nexport function isPostpone(error: any): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  )\n}\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\n","export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicExpression: undefined | string\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicExpression: undefined,\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    // TODO: it makes no sense to have these work unit store types during a dev render.\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-client' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicExpression = expression\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: PrerenderStoreModern\n): AbortSignal {\n  const controller = new AbortController()\n\n  if (workUnitStore.cacheSignal) {\n    // If we have a cacheSignal it means we're in a prospective render. If the input\n    // we're waiting on is coming from another cache, we do want to wait for it so that\n    // we can resolve this cache entry too.\n    workUnitStore.cacheSignal.inputReady().then(() => {\n      controller.abort()\n    })\n  } else {\n    // Otherwise we're in the final render and we should already have all our caches\n    // filled. We might still be waiting on some microtasks so we wait one tick before\n    // giving up. When we give up, we still want to render the content of this cache\n    // as deeply as we can so that we can suspend as deeply as possible in the tree\n    // or not at all if we don't end up waiting for the input.\n    scheduleOnNextTick(() => controller.abort())\n  }\n\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n\n  if (\n    workStore &&\n    workStore.isStaticGeneration &&\n    workStore.fallbackRouteParams &&\n    workStore.fallbackRouteParams.size > 0\n  ) {\n    // There are fallback route params, we should track these as dynamic\n    // accesses.\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      // We're prerendering with dynamicIO or PPR or both\n      if (workUnitStore.type === 'prerender-client') {\n        // We are in a prerender with dynamicIO semantics\n        // We are going to hang here and never resolve. This will cause the currently\n        // rendering component to effectively be a dynamic hole\n        React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // We're prerendering with PPR\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasSuspenseAfterBodyOrHtmlRegex =\n  /\\n\\s+at (?:body|html) \\(<anonymous>\\)[\\s\\S]*?\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  route: string,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (hasSuspenseAfterBodyOrHtmlRegex.test(componentStack)) {\n    // This prerender has a Suspense boundary above the body which\n    // effectively opts the page into allowing 100% dynamic rendering\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nfunction createErrorWithComponentStack(\n  message: string,\n  componentStack: string\n) {\n  const error = new Error(message)\n  error.stack = 'Error: ' + message + componentStack\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (workStore.invalidDynamicUsageError) {\n    console.error(workStore.invalidDynamicUsageError)\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    if (serverDynamic.syncDynamicErrorWithStack) {\n      // There is no shell and the server did something sync dynamic likely\n      // leading to an early termination of the prerender before the shell\n      // could be completed.\n      console.error(serverDynamic.syncDynamicErrorWithStack)\n      // We terminate the build/validating render\n      throw new StaticGenBailoutError()\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        console.error(dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport { isDynamicPostpone } from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n","/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\nclass ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n","import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { workAsyncStorage } from '../../server/app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../../server/app-render/work-unit-async-storage.external'\n\nexport function bailoutToClientRendering(reason: string): void | never {\n  const workStore = workAsyncStorage.getStore()\n\n  if (workStore?.forceStatic) return\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        throw new BailoutToCSRError(reason)\n      default:\n    }\n  }\n}\n","import type { FlightRouterState } from '../../server/app-render/types'\nimport type { Params } from '../../server/request/params'\n\nimport { useContext, useMemo } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { getSegmentValue } from './router-reducer/reducers/get-segment-value'\nimport { PAGE_SEGMENT_KEY, DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './navigation.react-server'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  if (typeof window === 'undefined') {\n    // AsyncLocalStorage should not be included in the client bundle.\n    const { bailoutToClientRendering } =\n      require('./bailout-to-client-rendering') as typeof import('./bailout-to-client-rendering')\n    // TODO-APP: handle dynamic = 'force-static' here and on the client\n    bailoutToClientRendering('useSearchParams()')\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  return useContext(PathnameContext) as string\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  return useContext(PathParamsContext) as T\n}\n\n/** Get the canonical parameters from the current level to the leaf node. */\n// Client components API\nfunction getSelectedLayoutSegmentPath(\n  tree: FlightRouterState,\n  parallelRouteKey: string,\n  first = true,\n  segmentPath: string[] = []\n): string[] {\n  let node: FlightRouterState\n  if (first) {\n    // Use the provided parallel route key on the first parallel route\n    node = tree[1][parallelRouteKey]\n  } else {\n    // After first parallel route prefer children, if there's no children pick the first parallel route.\n    const parallelRoutes = tree[1]\n    node = parallelRoutes.children ?? Object.values(parallelRoutes)[0]\n  }\n\n  if (!node) return segmentPath\n  const segment = node[0]\n\n  let segmentValue = getSegmentValue(segment)\n\n  if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\n    return segmentPath\n  }\n\n  segmentPath.push(segmentValue)\n\n  return getSelectedLayoutSegmentPath(\n    node,\n    parallelRouteKey,\n    false,\n    segmentPath\n  )\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {\n    return null\n  }\n\n  const selectedLayoutSegment =\n    parallelRouteKey === 'children'\n      ? selectedLayoutSegments[0]\n      : selectedLayoutSegments[selectedLayoutSegments.length - 1]\n\n  // if the default slot is showing, we return null since it's not technically \"selected\" (it's a fallback)\n  // and returning an internal value like `__DEFAULT__` would be confusing.\n  return selectedLayoutSegment === DEFAULT_SEGMENT_KEY\n    ? null\n    : selectedLayoutSegment\n}\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n","'use client'\nimport React, { useEffect } from 'react'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useRouter } from './navigation'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { RedirectType, isRedirectError } from './redirect-error'\n\ninterface RedirectBoundaryProps {\n  router: AppRouterInstance\n  children: React.ReactNode\n}\n\nfunction HandleRedirect({\n  redirect,\n  reset,\n  redirectType,\n}: {\n  redirect: string\n  redirectType: RedirectType\n  reset: () => void\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    React.startTransition(() => {\n      if (redirectType === RedirectType.push) {\n        router.push(redirect, {})\n      } else {\n        router.replace(redirect, {})\n      }\n      reset()\n    })\n  }, [redirect, redirectType, reset, router])\n\n  return null\n}\n\nexport class RedirectErrorBoundary extends React.Component<\n  RedirectBoundaryProps,\n  { redirect: string | null; redirectType: RedirectType | null }\n> {\n  constructor(props: RedirectBoundaryProps) {\n    super(props)\n    this.state = { redirect: null, redirectType: null }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isRedirectError(error)) {\n      const url = getURLFromRedirectError(error)\n      const redirectType = getRedirectTypeFromError(error)\n      return { redirect: url, redirectType }\n    }\n    // Re-throw if error is not for redirect\n    throw error\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    const { redirect, redirectType } = this.state\n    if (redirect !== null && redirectType !== null) {\n      return (\n        <HandleRedirect\n          redirect={redirect}\n          redirectType={redirectType}\n          reset={() => this.setState({ redirect: null })}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport function RedirectBoundary({ children }: { children: React.ReactNode }) {\n  const router = useRouter()\n  return (\n    <RedirectErrorBoundary router={router}>{children}</RedirectErrorBoundary>\n  )\n}\n","let warnOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const warnings = new Set<string>()\n  warnOnce = (msg: string) => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\nexport { warnOnce }\n","'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  children: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n","import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\nexport function extractInterceptionRouteInformation(path: string) {\n  let interceptingRoute: string | undefined,\n    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n    interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","import type { FlightRouterState } from '../../server/app-render/types'\nimport { useState } from 'react'\n\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1\n\nexport type RouterBFCacheEntry = {\n  tree: FlightRouterState\n  stateKey: string\n  // The entries form a linked list, sorted in order of most recently active.\n  next: RouterBFCacheEntry | null\n}\n\n/**\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n * tracks the last N param values that the router rendered for N.\n *\n * The result of this hook precisely determines the number and order of\n * trees that are rendered in parallel at their segment level.\n *\n * The purpose of this cache is to we can preserve the React and DOM state of\n * some number of inactive trees, by rendering them in an <Activity> boundary.\n * That means it would not make sense for the the lifetime of the cache to be\n * any longer than the lifetime of the React tree; e.g. if the hook were\n * unmounted, then the React tree would be, too. So, we use React state to\n * manage it.\n *\n * Note that we don't store the RSC data for the cache entries in this hook —\n * the data for inactive segments is stored in the parent CacheNode, which\n * *does* have a longer lifetime than the React tree. This hook only determines\n * which of those trees should have their *state* preserved, by <Activity>.\n */\nexport function useRouterBFCache(\n  activeTree: FlightRouterState,\n  activeStateKey: string\n): RouterBFCacheEntry {\n  // The currently active entry. The entries form a linked list, sorted in\n  // order of most recently active. This allows us to reuse parts of the list\n  // without cloning, unless there's a reordering or removal.\n  // TODO: Once we start tracking back/forward history at each route level,\n  // we should use the history order instead. In other words, when traversing\n  // to an existing entry as a result of a popstate event, we should maintain\n  // the existing order instead of moving it to the front of the list. I think\n  // an initial implementation of this could be to pass an incrementing id\n  // to history.pushState/replaceState, then use that here for ordering.\n  const [prevActiveEntry, setPrevActiveEntry] = useState<RouterBFCacheEntry>(\n    () => {\n      const initialEntry: RouterBFCacheEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null,\n      }\n      return initialEntry\n    }\n  )\n\n  if (prevActiveEntry.tree === activeTree) {\n    // Fast path. The active tree hasn't changed, so we can reuse the\n    // existing state.\n    return prevActiveEntry\n  }\n\n  // The route tree changed. Note that this doesn't mean that the tree changed\n  // *at this level* — the change may be due to a child route. Either way, we\n  // need to either add or update the router tree in the bfcache.\n  //\n  // The rest of the code looks more complicated than it actually is because we\n  // can't mutate the state in place; we have to copy-on-write.\n\n  // Create a new entry for the active cache key. This is the head of the new\n  // linked list.\n  const newActiveEntry: RouterBFCacheEntry = {\n    tree: activeTree,\n    stateKey: activeStateKey,\n    next: null,\n  }\n\n  // We need to append the old list onto the new list. If the head of the new\n  // list was already present in the cache, then we'll need to clone everything\n  // that came before it. Then we can reuse the rest.\n  let n = 1\n  let oldEntry: RouterBFCacheEntry | null = prevActiveEntry\n  let clonedEntry: RouterBFCacheEntry = newActiveEntry\n  while (oldEntry !== null && n < MAX_BF_CACHE_ENTRIES) {\n    if (oldEntry.stateKey === activeStateKey) {\n      // Fast path. This entry in the old list that corresponds to the key that\n      // is now active. We've already placed a clone of this entry at the front\n      // of the new list. We can reuse the rest of the old list without cloning.\n      // NOTE: We don't need to worry about eviction in this case because we\n      // haven't increased the size of the cache, and we assume the max size\n      // is constant across renders. If we were to change it to a dynamic limit,\n      // then the implementation would need to account for that.\n      clonedEntry.next = oldEntry.next\n      break\n    } else {\n      // Clone the entry and append it to the list.\n      n++\n      const entry: RouterBFCacheEntry = {\n        tree: oldEntry.tree,\n        stateKey: oldEntry.stateKey,\n        next: null,\n      }\n      clonedEntry.next = entry\n      clonedEntry = entry\n    }\n    oldEntry = oldEntry.next\n  }\n\n  setPrevActiveEntry(newActiveEntry)\n  return newActiveEntry\n}\n","'use client'\n\nimport type {\n  CacheNode,\n  LazyCacheNode,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../server/app-render/types'\nimport type { ErrorComponent } from './error-boundary'\nimport {\n  ACTION_SERVER_PATCH,\n  type FocusAndScrollRef,\n} from './router-reducer/router-reducer-types'\n\nimport React, {\n  useContext,\n  use,\n  startTransition,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { fetchServerResponse } from './router-reducer/fetch-server-response'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { handleSmoothScroll } from '../../shared/lib/router/utils/handle-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\n\nconst Activity = process.env.__NEXT_ROUTER_BF_CACHE\n  ? (require('react') as typeof import('react')).unstable_Activity\n  : null!\n\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\nfunction walkAddRefetch(\n  segmentPathToWalk: FlightSegmentPath | undefined,\n  treeToRecreate: FlightRouterState\n): FlightRouterState {\n  if (segmentPathToWalk) {\n    const [segment, parallelRouteKey] = segmentPathToWalk\n    const isLast = segmentPathToWalk.length === 2\n\n    if (matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          const subTree = walkAddRefetch(\n            undefined,\n            treeToRecreate[1][parallelRouteKey]\n          )\n          return [\n            treeToRecreate[0],\n            {\n              ...treeToRecreate[1],\n              [parallelRouteKey]: [\n                subTree[0],\n                subTree[1],\n                subTree[2],\n                'refetch',\n              ],\n            },\n          ]\n        }\n\n        return [\n          treeToRecreate[0],\n          {\n            ...treeToRecreate[1],\n            [parallelRouteKey]: walkAddRefetch(\n              segmentPathToWalk.slice(2),\n              treeToRecreate[1][parallelRouteKey]\n            ),\n          },\n        ]\n      }\n    }\n  }\n\n  return treeToRecreate\n}\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',\n        element\n      )\n    }\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      handleSmoothScroll(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  cacheNode,\n  url,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  cacheNode: CacheNode\n  url: string\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const { tree: fullTree } = context\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  const resolvedRsc: React.ReactNode =\n    typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'\n      ? use(rsc)\n      : rsc\n\n  if (!resolvedRsc) {\n    // The data for this segment is not available, and there's no pending\n    // navigation that will be able to fulfill it. We need to fetch more from\n    // the server and patch the cache.\n\n    // Check if there's already a pending request.\n    let lazyData = cacheNode.lazyData\n    if (lazyData === null) {\n      /**\n       * Router state with refetch marker added\n       */\n      // TODO-APP: remove ''\n      const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n      const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n      const navigatedAt = Date.now()\n      cacheNode.lazyData = lazyData = fetchServerResponse(\n        new URL(url, location.origin),\n        {\n          flightRouterState: refetchTree,\n          nextUrl: includeNextUrl ? context.nextUrl : null,\n        }\n      ).then((serverResponse) => {\n        startTransition(() => {\n          dispatchAppRouterAction({\n            type: ACTION_SERVER_PATCH,\n            previousTree: fullTree,\n            serverResponse,\n            navigatedAt,\n          })\n        })\n\n        return serverResponse\n      })\n\n      // Suspend while waiting for lazyData to resolve\n      use(lazyData)\n    }\n    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n    use(unresolvedThenable) as never\n  }\n\n  // If we get to this point, then we know we have something we can render.\n  const subtree = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n      }}\n    >\n      {resolvedRsc}\n    </LayoutRouterContext.Provider>\n  )\n  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n  return subtree\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  loading,\n  children,\n}: {\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server — which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\nfunction RenderChildren({ children }: { children: React.ReactNode }) {\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  gracefullyDegrade,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  gracefullyDegrade?: boolean\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const { parentTree, parentCacheNode, parentSegmentPath, url } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React — it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  const activeSegment = activeTree[0]\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment — we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n    const cacheKey = createRouterCacheKey(segment)\n\n    // Read segment path from the parallel router cache node.\n    let cacheNode = segmentMap.get(cacheKey)\n    if (cacheNode === undefined) {\n      // When data is not available during rendering client-side we need to fetch\n      // it from the server.\n      const newLazyCacheNode: LazyCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n\n      // Flight data fetch kicked off during render and put into the cache.\n      cacheNode = newLazyCacheNode\n      segmentMap.set(cacheKey, newLazyCacheNode)\n    }\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    const ErrorBoundaryComponent = gracefullyDegrade\n      ? RenderChildren\n      : ErrorBoundary\n\n    // TODO: The loading module data for a segment is stored on the parent, then\n    // applied to each of that parent segment's parallel route slots. In the\n    // simple case where there's only one parallel route (the `children` slot),\n    // this is no different from if the loading module data where stored on the\n    // child directly. But I'm not sure this actually makes sense when there are\n    // multiple parallel routes. It's not a huge issue because you always have\n    // the option to define a narrower loading boundary for a particular slot. But\n    // this sort of smells like an implementation accident to me.\n    const loadingModuleData = parentCacheNode.loading\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundaryComponent\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary loading={loadingModuleData}>\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                    />\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundaryComponent>\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.__NEXT_ROUTER_BF_CACHE) {\n      child = (\n        <Activity\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  // fallthrough\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  // fallthrough\n  'status',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  // fallthrough\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","import type { SearchParams } from '../../server/request/search-params'\n\nimport { wellKnownProperties } from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nexport function makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingSearchParams[prop]\n    }\n  })\n\n  return promise\n}\n","export const createRenderSearchParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (\n        require('./search-params.browser.dev') as typeof import('./search-params.browser.dev')\n      ).makeUntrackedExoticSearchParamsWithDevWarnings\n    : (\n        require('./search-params.browser.prod') as typeof import('./search-params.browser.prod')\n      ).makeUntrackedExoticSearchParams\n","import type { Params } from '../../server/request/params'\nimport { wellKnownProperties } from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nexport function makeUntrackedExoticParams(\n  underlyingParams: Params\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n","export const createRenderParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (require('./params.browser.dev') as typeof import('./params.browser.dev'))\n        .makeDynamicallyTrackedExoticParamsWithDevWarnings\n    : (\n        require('./params.browser.prod') as typeof import('./params.browser.prod')\n      ).makeUntrackedExoticParams\n","export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n","import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackDynamicDataInDynamicRender,\n  annotateDynamicAccess,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\nimport { scheduleImmediate } from '../../lib/scheduler'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedSearchParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { searchParams: Promise<{ foo: string }> }\n *\n * export default async function Page(props: Props) {\n *  const { searchParams } = (props.searchParams as unknown as UnsafeUnwrappedSearchParams<typeof props.searchParams>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedSearchParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore)\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (\n    prerenderStore &&\n    (prerenderStore.type === 'prerender' ||\n      prerenderStore.type === 'prerender-client')\n  ) {\n    // dynamicIO Prerender\n    // We're prerendering in a mode that aborts (dynamicIO) and should stall\n    // the promise to ensure the RSC side is considered dynamic\n    return makeHangingPromise(prerenderStore.renderSignal, '`searchParams`')\n  }\n  // We're prerendering in a mode that does not aborts. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve({})\n}\n\nfunction createPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a dynamicIO (PPR or otherwise) prerender\n      return makeAbortingExoticSearchParams(workStore.route, prerenderStore)\n    default:\n      // The remaining cases are prerender-ppr and prerender-legacy\n      // We are in a legacy static generation and need to interrupt the prerender\n      // when search params are accessed.\n      return makeErroringExoticSearchParams(workStore, prerenderStore)\n  }\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      !workStore.isPrefetchRequest\n    ) {\n      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore\n      )\n    } else {\n      return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeAbortingExoticSearchParams(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            const error = createSearchAccessError(route, expression)\n            abortAndThrowOnSynchronousRequestDataAccess(\n              route,\n              expression,\n              error,\n              prerenderStore\n            )\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        const error = createSearchAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      const error = createSearchAccessError(route, expression)\n      abortAndThrowOnSynchronousRequestDataAccess(\n        route,\n        expression,\n        error,\n        prerenderStore\n      )\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringExoticSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no dynamicIO)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          if (workStore.dynamicShouldError) {\n            throwWithStaticGenerationBailoutErrorWithDynamicError(\n              workStore.route,\n              expression\n            )\n          } else if (prerenderStore.type === 'prerender-ppr') {\n            // PPR Prerender (no dynamicIO)\n            postponeWithTracking(\n              workStore.route,\n              expression,\n              prerenderStore.dynamicTracking\n            )\n          } else {\n            // Legacy Prerender\n            throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              prerenderStore\n            )\n          }\n          return\n        }\n        default: {\n          if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\n            const expression = describeStringPropertyAccess(\n              'searchParams',\n              prop\n            )\n            if (workStore.dynamicShouldError) {\n              throwWithStaticGenerationBailoutErrorWithDynamicError(\n                workStore.route,\n                expression\n              )\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          }\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = describeHasCheckingStringProperty(\n          'searchParams',\n          prop\n        )\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no dynamicIO)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n        return false\n      }\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys() {\n      const expression =\n        '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n      if (workStore.dynamicShouldError) {\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      } else if (prerenderStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          prerenderStore.dynamicTracking\n        )\n      } else {\n        // Legacy Prerender\n        throwToInterruptStaticGeneration(expression, workStore, prerenderStore)\n      }\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringExoticSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringExoticSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has: function has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests throw an error. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, has)\n      }\n\n      return ReflectAdapter.has(target, prop)\n    },\n    ownKeys: function ownKeys() {\n      throwForSearchParamsAccessInUseCache(workStore, ownKeys)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (!wellKnownProperties.has(prop)) {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const workUnitStore = workUnitAsyncStorage.getStore()\n          trackDynamicDataInDynamicRender(store, workUnitStore)\n          return underlyingSearchParams[prop]\n        },\n        set(value) {\n          Object.defineProperty(promise, prop, {\n            value,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n        const workUnitStore = workUnitAsyncStorage.getStore()\n        trackDynamicDataInDynamicRender(store, workUnitStore)\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise<SearchParams>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingSearchParams))\n  )\n  promise.then(() => {\n    promiseInitialized = true\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      Object.defineProperty(promise, prop, {\n        get() {\n          return proxiedUnderlying[prop]\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && store.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          syncIODev(store.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin or well-known property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n","import type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n      default:\n      // fallthrough\n    }\n  }\n  return createRenderParams(underlyingParams, workStore)\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (\n    prerenderStore &&\n    (prerenderStore.type === 'prerender' ||\n      prerenderStore.type === 'prerender-client')\n  ) {\n    const fallbackParams = workStore.fallbackRouteParams\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return makeHangingPromise(prerenderStore.renderSignal, '`params`')\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStore\n): Promise<Params> {\n  const fallbackParams = workStore.fallbackRouteParams\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true\n        break\n      }\n    }\n\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      switch (prerenderStore.type) {\n        case 'prerender':\n        case 'prerender-client':\n          // We are in a dynamicIO prerender\n          return makeAbortingExoticParams(\n            underlyingParams,\n            workStore.route,\n            prerenderStore\n          )\n        default:\n          return makeErroringExoticParams(\n            underlyingParams,\n            fallbackParams,\n            workStore,\n            prerenderStore\n          )\n      }\n    }\n  }\n\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  if (process.env.NODE_ENV === 'development' && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n      underlyingParams,\n      workStore\n    )\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeAbortingExoticParams(\n  underlyingParams: Params,\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(prerenderStore.renderSignal, '`params`'),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const expression = describeStringPropertyAccess('params', prop)\n          const error = createParamsAccessError(route, expression)\n          abortAndThrowOnSynchronousRequestDataAccess(\n            route,\n            expression,\n            error,\n            prerenderStore\n          )\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n          })\n        },\n        enumerable: true,\n        configurable: true,\n      })\n    }\n  })\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise<Params>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingParams))\n  )\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when dynamicIO is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","'use client'\n\n// This is a client component that only renders during SSR,\n// but will be replaced during streaming with an icon insertion script tag.\n// We don't want it to be presented anywhere so it's only visible during streaming,\n// right after the icon meta tags so that browser can pick it up as soon as it's rendered.\n// Note: we don't just emit the script here because we only need the script if it's not in the head,\n// and we need it to be hoistable alongside the other metadata but sync scripts are not hoistable.\nexport const IconMark = () => {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  return <meta name=\"«nxt-icon»\" />\n}\n","'use client'\n\nimport { Suspense, use } from 'react'\nimport type { StreamingMetadataResolvedState } from './types'\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layer；\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n","'use client'\n\nimport { HandleISRError } from './handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction GlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default GlobalError\n","'use client'\n\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../../lib/metadata/metadata-constants'\n\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n  [METADATA_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: React.ReactNode\n  }) {\n    return children\n  },\n  [VIEWPORT_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: React.ReactNode\n  }) {\n    return children\n  },\n  [OUTLET_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: React.ReactNode\n  }) {\n    return children\n  },\n}\n\nexport const MetadataBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[METADATA_BOUNDARY_NAME.slice(0) as typeof METADATA_BOUNDARY_NAME]\n\nexport const ViewportBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[VIEWPORT_BOUNDARY_NAME.slice(0) as typeof VIEWPORT_BOUNDARY_NAME]\n\nexport const OutletBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[OUTLET_BOUNDARY_NAME.slice(0) as typeof OUTLET_BOUNDARY_NAME]\n"],"names":["ACTION_REFRESH","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_SERVER_PATCH","ACTION_PREFETCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","PrefetchKind","PrefetchCacheEntryStatus","RSC_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_URL","RSC_CONTENT_TYPE_HEADER","FLIGHT_HEADERS","NEXT_RSC_UNION_QUERY","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_IS_PRERENDER_HEADER","isThenable","promise","then","React","use","dispatch","dispatchAppRouterAction","action","Error","useActionQueue","actionQueue","state","setState","useState","process","env","NODE_ENV","useAppDevRenderingIndicator","require","appDevRenderingIndicator","startTransition","callServer","actionId","actionArgs","Promise","resolve","reject","type","basePath","__NEXT_ROUTER_BASEPATH","pathname","findSourceMapURL","filename","startsWith","document","location","origin","includes","url","URL","searchParams","set","href","undefined","getFlightDataPartsFromPath","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","slice","segmentPath","pathToSegment","segment","length","isRootRender","getNextFlightSegmentPath","flightSegmentPath","normalizeFlightData","flightData","map","globalBuildId","setAppBuildId","buildId","getAppBuildId","djb2Hash","str","hash","i","char","charCodeAt","hexHash","toString","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","join","setCacheBustingSearchParam","headers","uniqueCacheKey","existingSearch","search","rawQuery","pairs","split","filter","pair","push","createFromReadableStream","NEXT_RUNTIME","urlToUrlWithoutFlightMarker","urlWithoutFlightParameters","delete","__NEXT_CONFIG_OUTPUT","endsWith","doMpaNavigation","canonicalUrl","couldBeIntercepted","prerendered","postponed","staleTime","abortController","AbortController","window","addEventListener","abort","fetchServerResponse","options","flightRouterState","nextUrl","prefetchKind","encodeURIComponent","JSON","stringify","AUTO","isHmrRefresh","res","fetchPriority","TEMPORARY","createFetch","signal","responseUrl","redirected","contentType","get","interception","staleTimeHeaderSeconds","parseInt","isFlightResponse","ok","body","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightStream","createUnclosingPrefetchStream","response","createFromNextReadableStream","b","f","S","err","aborted","console","error","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","fetchOptions","credentials","priority","fetchUrl","browserResponse","fetch","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","rscResponse","status","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue","unresolvedThenable","useContext","PathnameContext","hasFallbackRouteParams","workAsyncStorage","workStore","getStore","fallbackRouteParams","size","useUntrackedPathname","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","HTTP_ERROR_FALLBACK_ERROR_CODE","isHTTPAccessFallbackError","digest","prefix","httpStatus","has","Number","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","errorCode","destination","at","statusCode","isNaN","isNextRouterError","createHrefFromUrl","includeHash","useEffect","handleHardNavError","next","__pendingUrl","useNavFailureHandler","__NEXT_APP_NAV_FAIL_HANDLING","uncaughtExceptionHandler","evt","reason","removeEventListener","HandleISRError","store","isRevalidate","isStaticGeneration","ErrorBoundaryHandler","Component","getDerivedStateFromError","getDerivedStateFromProps","props","previousPathname","render","errorStyles","errorScripts","this","errorComponent","reset","children","constructor","ErrorBoundary","matchSegment","existingSegment","handleSmoothScroll","fn","onlyHashChange","htmlElement","documentElement","existing","style","scrollBehavior","dontForceLayout","getClientRects","getSegmentValue","Array","isArray","isGroupSegment","isParallelRouteSegment","addSearchParamsIfPageSegment","isPageSegment","PAGE_SEGMENT_KEY","stringifiedQuery","DEFAULT_SEGMENT_KEY","actionAsyncStorage","getRedirectError","TemporaryRedirect","redirect","isAction","replace","permanentRedirect","PermanentRedirect","getURLFromRedirectError","getRedirectTypeFromError","getRedirectStatusCodeFromError","DIGEST","notFound","forbidden","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","unauthorized","BAILOUT_TO_CSR","BailoutToCSRError","isBailoutToCSRError","unstable_rethrow","cause","isHangingPromiseRejectionError","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","expression","abortListenersBySignal","WeakMap","makeHangingPromise","hangingPromise","_","boundRejection","bind","currentListeners","listeners","once","catch","ignoreReject","REACT_POSTPONE_TYPE","Symbol","for","isPostpone","$$typeof","DYNAMIC_ERROR_CODE","DynamicServerError","description","isDynamicServerError","NEXT_STATIC_GEN_BAILOUT","StaticGenBailoutError","code","isStaticGenBailoutError","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","scheduleOnNextTick","cb","setTimeout","nextTick","scheduleImmediate","setImmediate","atLeastOneTask","waitAtLeastOneReactRenderTask","r","workUnitAsyncStorage","hasPostpone","unstable_postpone","createDynamicTrackingState","isDebugDynamicAccesses","dynamicAccesses","syncDynamicExpression","syncDynamicErrorWithStack","createDynamicValidationState","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","getFirstDynamicReason","trackingState","markCurrentScopeAsDynamic","workUnitStore","forceDynamic","forceStatic","dynamicShouldError","route","postponeWithTracking","dynamicTracking","revalidate","dynamicUsageDescription","dynamicUsageStack","stack","usedDynamic","trackFallbackParamAccessed","prerenderStore","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","_store","abortOnSynchronousDynamicDataAccess","createPrerenderInterruptedError","abortOnSynchronousPlatformIOAccess","errorWithStack","trackSynchronousPlatformIOAccessInDev","requestStore","prerenderPhase","abortAndThrowOnSynchronousRequestDataAccess","prerenderSignal","trackSynchronousRequestDataAccessInDev","Postpone","assertPostpone","createPostponeReason","isDynamicPostpone","message","isDynamicPostponeReason","NEXT_PRERENDER_INTERRUPTED","isPrerenderInterruptedError","accessedDynamicData","consumeDynamicAccess","serverDynamic","clientDynamic","formatDynamicAPIAccesses","access","line","createPostponedAbortSignal","x","createHangingInputAbortSignal","cacheSignal","inputReady","annotateDynamicAccess","useDynamicRouteParams","renderSignal","hasSuspenseRegex","hasSuspenseAfterBodyOrHtmlRegex","hasMetadataRegex","RegExp","hasViewportRegex","hasOutletRegex","trackAllowedDynamicAccess","componentStack","dynamicValidation","test","createErrorWithComponentStack","PreludeState","throwIfDisallowedDynamic","prelude","invalidDynamicUsageError","ReadonlyURLSearchParamsError","ReadonlyURLSearchParams","URLSearchParams","append","sort","bailoutToClientRendering","useMemo","AppRouterContext","LayoutRouterContext","SearchParamsContext","PathParamsContext","useSearchParams","readonlySearchParams","usePathname","ServerInsertedHTMLContext","useServerInsertedHTML","useRouter","router","useParams","getSelectedLayoutSegmentPath","parallelRouteKey","first","node","parallelRoutes","segmentValue","useSelectedLayoutSegments","context","parentTree","useSelectedLayoutSegment","selectedLayoutSegments","selectedLayoutSegment","HandleRedirect","redirectType","RedirectErrorBoundary","RedirectBoundary","warnOnce","warnings","msg","warn","add","MissingSlotContext","HTTPAccessFallbackErrorBoundary","componentDidCatch","missingSlots","warningMessage","formattedSlots","from","a","localeCompare","slot","triggeredStatus","errorComponents","isNotFound","isForbidden","isUnauthorized","meta","name","content","HTTPAccessFallbackBoundary","hasErrorFallback","createRouterCacheKey","withoutSearchParameters","ensureLeadingSlash","path","normalizeAppPath","reduce","index","segments","normalizeRscURL","INTERCEPTION_ROUTE_MARKERS","isInterceptionRouteAppPath","find","m","extractInterceptionRouteInformation","interceptingRoute","marker","interceptedRoute","concat","splitInterceptingRoute","hasInterceptionRouteInCurrentTree","key","MAX_BF_CACHE_ENTRIES","__NEXT_ROUTER_BF_CACHE","useRouterBFCache","activeTree","activeStateKey","prevActiveEntry","setPrevActiveEntry","initialEntry","stateKey","newActiveEntry","oldEntry","clonedEntry","entry","Suspense","useDeferredValue","ReactDOM","GlobalLayoutRouterContext","TemplateContext","Activity","unstable_Activity","walkAddRefetch","segmentPathToWalk","treeToRecreate","isLast","hasOwnProperty","subTree","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","findDOMNode","instance","internal_reactDOMfindDOMNode","rectProperties","shouldSkipElement","element","getComputedStyle","position","rect","getBoundingClientRect","every","item","topOfElementInViewport","viewportHeight","top","getHashFragmentDomNode","hashFragment","getElementById","getElementsByName","InnerScrollAndFocusHandler","componentDidMount","handlePotentialScroll","componentDidUpdate","focusAndScrollRef","apply","segmentPaths","some","scrollRefSegmentPath","domNode","Element","HTMLElement","parentElement","localName","nextElementSibling","scrollIntoView","clientHeight","scrollTop","focus","ScrollAndFocusHandler","InnerLayoutRouter","cacheNode","fullTree","resolvedPrefetchRsc","prefetchRsc","rsc","resolvedRsc","lazyData","refetchTree","includeNextUrl","navigatedAt","Date","now","serverResponse","previousTree","subtree","Provider","parentCacheNode","parentSegmentPath","LoadingBoundary","loading","loadingModuleData","promiseForLoading","loadingRsc","loadingStyles","loadingScripts","fallback","RenderChildren","OuterLayoutRouter","parallelRouterKey","templateStyles","templateScripts","template","gracefullyDegrade","parentParallelRoutes","segmentMap","Map","parentTreeSegment","activeSegment","bfcacheEntry","cacheKey","newLazyCacheNode","prefetchHead","ErrorBoundaryComponent","child","mode","RenderFromTemplateContext","InvariantError","isDefinitelyAValidIdentifier","describeStringPropertyAccess","target","prop","describeHasCheckingStringProperty","stringifiedProp","wellKnownProperties","CachedSearchParams","makeUntrackedExoticSearchParams","underlyingSearchParams","cachedSearchParams","keys","forEach","createRenderSearchParamsFromClient","makeUntrackedExoticSearchParamsWithDevWarnings","CachedParams","makeUntrackedExoticParams","underlyingParams","cachedParams","createRenderParamsFromClient","makeDynamicallyTrackedExoticParamsWithDevWarnings","ReflectAdapter","receiver","Reflect","deleteProperty","errorRef","current","cache","logErrorOrWarn","__NEXT_DYNAMIC_IO","flushCurrentErrorIfNew","createDedupedByCallsiteServerErrorLoggerDev","getMessage","logDedupedError","args","callStackFrames","afterTaskAsyncStorage","throwWithStaticGenerationBailoutError","throwWithStaticGenerationBailoutErrorWithDynamicError","throwForSearchParamsAccessInUseCache","constructorOpt","captureStackTrace","isRequestAPICallableInsideAfter","afterTaskStore","rootTaskSpawnPhase","createSearchParamsFromClient","createPrerenderSearchParams","createRenderSearchParams","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","createPrerenderSearchParamsForClientPage","makeAbortingExoticSearchParams","makeErroringExoticSearchParams","isPrefetchRequest","makeDynamicallyTrackedExoticSearchParamsWithDevWarnings","CachedSearchParamsForUseCache","proxiedPromise","Proxy","hasOwn","createSearchAccessError","ownKeys","makeErroringExoticSearchParamsForUseCache","defineProperty","writable","enumerable","configurable","proxiedProperties","unproxiedProperties","promiseInitialized","proxiedUnderlying","newValue","syncIODev","missingProperties","warnForIncompleteEnumeration","warnForSyncAccess","createIncompleteEnumerationError","describeListOfPropertyNames","properties","dynamicAccessAsyncStorage","createParamsFromClient","createPrerenderParams","createRenderParams","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","createPrerenderParamsForClientSegment","fallbackParams","hasSomeFallbackParams","makeAbortingExoticParams","makeErroringExoticParams","fallbackParamsProxyHandler","originalMethod","createParamsAccessError","augmentedUnderlying","ClientPageRoot","params","promises","clientSearchParams","clientParams","ClientSegmentRoot","slots","IconMark","MetadataOutlet","AsyncMetadataOutlet","styles","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","GlobalError","html","id","div","h2","hostname","p","NameSpace","MetadataBoundary","ViewportBoundary","OutletBoundary"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]}