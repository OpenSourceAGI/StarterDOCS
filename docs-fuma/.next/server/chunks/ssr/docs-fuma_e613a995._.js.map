{"version":3,"sources":["turbopack:///[project]/docs-fuma/node_modules/next/dist/src/build/templates/app-page.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport {\n  AppPageRouteModule,\n  type AppPageRouteHandlerContext,\n} from '../../server/route-modules/app-page/module.compiled' with { 'turbopack-transition': 'next-ssr' }\n\nimport { RouteKind } from '../../server/route-kind' with { 'turbopack-transition': 'next-server-utility' }\n\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\nimport { getRequestMeta } from '../../server/request-meta'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { interopDefault } from '../../server/app-render/interop-default'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\nimport {\n  getFallbackRouteParams,\n  type FallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport {\n  isHtmlBotRequest,\n  shouldServeStreamingMetadata,\n} from '../../server/lib/streaming-metadata'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n} from '../../client/components/app-router-headers'\nimport { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\nimport {\n  CachedRouteKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\nimport { decodePathParams } from '../../server/lib/router-utils/decode-path-params'\nimport { FallbackMode, parseFallbackField } from '../../lib/fallback'\nimport RenderResult from '../../server/render-result'\nimport { CACHE_ONE_YEAR, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport type { CacheControl } from '../../server/lib/cache-control'\nimport { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\nimport { sendRenderResult } from '../../server/send-payload'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n\n// These are injected by the loader afterwards.\n\n/**\n * The tree created in next-app-loader that holds component segments and modules\n * and I've updated it.\n */\ndeclare const tree: LoaderTree\ndeclare const pages: any\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\n// INJECT:tree\n// INJECT:pages\n\nexport { tree, pages }\n\nimport GlobalError from 'VAR_MODULE_GLOBAL_ERROR' with { 'turbopack-transition': 'next-server-utility' }\n\nexport { GlobalError }\n\n// These are injected by the loader afterwards.\ndeclare const __next_app_require__: (id: string | number) => unknown\ndeclare const __next_app_load_chunk__: (id: string | number) => Promise<unknown>\n\n// INJECT:__next_app_require__\n// INJECT:__next_app_load_chunk__\n\nexport const __next_app__ = {\n  require: __next_app_require__,\n  loadChunk: __next_app_load_chunk__,\n}\n\nimport * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\n\nexport * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n  definition: {\n    kind: RouteKind.APP_PAGE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n    appPaths: [],\n  },\n  userland: {\n    loaderTree: tree,\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const initialPostponed = getRequestMeta(req, 'postponed')\n  // TODO: replace with more specific flags\n  const minimalMode = getRequestMeta(req, 'minimalMode')\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    query,\n    params,\n    parsedUrl,\n    pageIsDynamic,\n    buildManifest,\n    nextFontManifest,\n    reactLoadableManifest,\n    serverActionsManifest,\n    clientReferenceManifest,\n    subresourceIntegrityManifest,\n    prerenderManifest,\n    isDraftMode,\n\n    revalidateOnlyGenerated,\n    routerServerContext,\n    nextConfig,\n  } = prepareResult\n\n  const pathname = parsedUrl.pathname || '/'\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let { isOnDemandRevalidate } = prepareResult\n\n  // TODO: rework this to not be necessary as a middleware\n  // rewrite should not need to pass this context like this\n  // maybe we rely on rewrite header instead\n  let resolvedPathname = getRequestMeta(req, 'rewroteURL') || pathname\n\n  if (resolvedPathname === '/index') {\n    resolvedPathname = '/'\n  }\n  resolvedPathname = decodePathParams(resolvedPathname)\n\n  const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n  const isPrerendered = prerenderManifest.routes[resolvedPathname]\n\n  let isSSG = Boolean(\n    prerenderInfo ||\n      isPrerendered ||\n      prerenderManifest.routes[normalizedSrcPage]\n  )\n\n  // if the page is dynamicParams: false and this pathname wasn't prerender\n  // trigger the no fallback handling\n  if (isSSG && prerenderInfo?.fallback === false && !isPrerendered) {\n    throw new NoFallbackError()\n  }\n\n  const userAgent = req.headers['user-agent'] || ''\n  const botType = getBotType(userAgent)\n  const isHtmlBot = isHtmlBotRequest(req)\n\n  /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */\n  const isPrefetchRSCRequest =\n    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n    Boolean(req.headers[NEXT_ROUTER_PREFETCH_HEADER])\n\n  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n  const isRSCRequest =\n    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n\n  const isPossibleServerAction = getIsPossibleServerAction(req)\n\n  /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */\n  const couldSupportPPR: boolean = checkIsAppPPREnabled(\n    nextConfig.experimental.ppr\n  )\n\n  // When enabled, this will allow the use of the `?__nextppronly` query to\n  // enable debugging of the static shell.\n  const hasDebugStaticShellQuery =\n    process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n    typeof query.__nextppronly !== 'undefined' &&\n    couldSupportPPR\n\n  // When enabled, this will allow the use of the `?__nextppronly` query\n  // to enable debugging of the fallback shell.\n  const hasDebugFallbackShellQuery =\n    hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n  // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n  // prerender manifest and this is an app page.\n  const isRoutePPREnabled: boolean =\n    couldSupportPPR &&\n    ((\n      prerenderManifest.routes[normalizedSrcPage] ??\n      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n    )?.renderingMode === 'PARTIALLY_STATIC' ||\n      // Ideally we'd want to check the appConfig to see if this page has PPR\n      // enabled or not, but that would require plumbing the appConfig through\n      // to the server during development. We assume that the page supports it\n      // but only during development.\n      (hasDebugStaticShellQuery &&\n        (routeModule.isDev === true ||\n          routerServerContext?.experimentalTestProxy === true)))\n\n  const isDebugStaticShell: boolean =\n    hasDebugStaticShellQuery && isRoutePPREnabled\n\n  // We should enable debugging dynamic accesses when the static shell\n  // debugging has been enabled and we're also in development mode.\n  const isDebugDynamicAccesses =\n    isDebugStaticShell && routeModule.isDev === true\n\n  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n  // If we're in minimal mode, then try to get the postponed information from\n  // the request metadata. If available, use it for resuming the postponed\n  // render.\n  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n\n  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n  // we can use this fact to only generate the flight data for the request\n  // because we can't cache the HTML (as it's also dynamic).\n  const isDynamicRSCRequest =\n    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n  // Need to read this before it's stripped by stripFlightHeaders. We don't\n  // need to transfer it to the request meta because it's only read\n  // within this function; the static segment data should have already been\n  // generated, so we will always either return a static response or a 404.\n  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n  // being true for a revalidate due to modifying the base-server this.renderOpts\n  // when fixing this to correct logic it causes hydration issue since we set\n  // serveStreamingMetadata to true during export\n  let serveStreamingMetadata = !userAgent\n    ? true\n    : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n\n  if (isHtmlBot && isRoutePPREnabled) {\n    isSSG = false\n    serveStreamingMetadata = false\n  }\n\n  // In development, we always want to generate dynamic HTML.\n  let supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG ||\n    // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof initialPostponed === 'string' ||\n    // If this is a dynamic RSC request, then this render supports dynamic\n    // HTML (it's dynamic).\n    isDynamicRSCRequest\n\n  // When html bots request PPR page, perform the full dynamic rendering.\n  const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n\n  let ssgCacheKey: string | null = null\n  if (\n    !isDraftMode &&\n    isSSG &&\n    !supportsDynamicResponse &&\n    !isPossibleServerAction &&\n    !minimalPostponed &&\n    !isDynamicRSCRequest\n  ) {\n    ssgCacheKey = resolvedPathname\n  }\n\n  const ComponentMod = {\n    ...entryBase,\n    tree,\n    pages,\n    GlobalError,\n    handler,\n    routeModule,\n    __next_app__,\n  }\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  try {\n    const invokeRouteModule = async (\n      span: Span | undefined,\n      context: AppPageRouteHandlerContext\n    ) => {\n      const nextReq = new NodeNextRequest(req)\n      const nextRes = new NodeNextResponse(res)\n\n      // TODO: adapt for putting the RDC inside the postponed data\n      // If we're in dev, and this isn't a prefetch or a server action,\n      // we should seed the resume data cache.\n      if (process.env.NODE_ENV === 'development') {\n        if (\n          nextConfig.experimental.dynamicIO &&\n          !isPrefetchRSCRequest &&\n          !context.renderOpts.isPossibleServerAction\n        ) {\n          const warmup = await routeModule.warmup(nextReq, nextRes, context)\n\n          // If the warmup is successful, we should use the resume data\n          // cache from the warmup.\n          if (warmup.metadata.renderResumeDataCache) {\n            context.renderOpts.renderResumeDataCache =\n              warmup.metadata.renderResumeDataCache\n          }\n        }\n      }\n\n      return routeModule.render(nextReq, nextRes, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${req.url}`)\n        }\n      })\n    }\n\n    const doRender = async ({\n      span,\n      postponed,\n      fallbackRouteParams,\n    }: {\n      span?: Span\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: FallbackRouteParams | null\n    }): Promise<ResponseCacheEntry> => {\n      const context: AppPageRouteHandlerContext = {\n        query,\n        params,\n        page: normalizedSrcPage,\n        sharedContext: {\n          buildId,\n        },\n        serverComponentsHmrCache: getRequestMeta(\n          req,\n          'serverComponentsHmrCache'\n        ),\n        fallbackRouteParams,\n        renderOpts: {\n          App: () => null,\n          Document: () => null,\n          pageConfig: {},\n          ComponentMod,\n          Component: interopDefault(ComponentMod),\n\n          params,\n          routeModule,\n          page: srcPage,\n          postponed,\n          shouldWaitOnAllReady,\n          serveStreamingMetadata,\n          supportsDynamicResponse:\n            typeof postponed === 'string' || supportsDynamicResponse,\n          buildManifest,\n          nextFontManifest,\n          reactLoadableManifest,\n          subresourceIntegrityManifest,\n          serverActionsManifest,\n          clientReferenceManifest,\n          setIsrStatus: routerServerContext?.setIsrStatus,\n\n          dir: routeModule.projectDir,\n          isDraftMode,\n          isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n          botType,\n          isOnDemandRevalidate,\n          isPossibleServerAction,\n          assetPrefix: nextConfig.assetPrefix,\n          nextConfigOutput: nextConfig.output,\n          crossOrigin: nextConfig.crossOrigin,\n          trailingSlash: nextConfig.trailingSlash,\n          previewProps: prerenderManifest.preview,\n          deploymentId: nextConfig.deploymentId,\n          enableTainting: nextConfig.experimental.taint,\n          htmlLimitedBots: nextConfig.htmlLimitedBots,\n          devtoolSegmentExplorer:\n            nextConfig.experimental.devtoolSegmentExplorer,\n          reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n\n          multiZoneDraftMode,\n          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n          cacheLifeProfiles: nextConfig.experimental.cacheLife,\n          basePath: nextConfig.basePath,\n          serverActions: nextConfig.experimental.serverActions,\n\n          ...(isDebugStaticShell || isDebugDynamicAccesses\n            ? {\n                nextExport: true,\n                supportsDynamicResponse: false,\n                isStaticGeneration: true,\n                isRevalidate: true,\n                isDebugDynamicAccesses: isDebugDynamicAccesses,\n              }\n            : {}),\n\n          experimental: {\n            isRoutePPREnabled,\n            expireTime: nextConfig.expireTime,\n            staleTimes: nextConfig.experimental.staleTimes,\n            dynamicIO: Boolean(nextConfig.experimental.dynamicIO),\n            clientSegmentCache: Boolean(\n              nextConfig.experimental.clientSegmentCache\n            ),\n            dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n            inlineCss: Boolean(nextConfig.experimental.inlineCss),\n            authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n            clientTraceMetadata:\n              nextConfig.experimental.clientTraceMetadata || ([] as any),\n          },\n\n          waitUntil: ctx.waitUntil,\n          onClose: (cb) => {\n            res.on('close', cb)\n          },\n          onAfterTaskError: () => {},\n\n          onInstrumentationRequestError: (error, _request, errorContext) =>\n            routeModule.onRequestError(\n              req,\n              error,\n              errorContext,\n              routerServerContext\n            ),\n          err: getRequestMeta(req, 'invokeError'),\n          dev: routeModule.isDev,\n        },\n      }\n\n      const result = await invokeRouteModule(span, context)\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = metadata.fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !routeModule.isDev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.APP_PAGE,\n          html: result,\n          headers,\n          rscData: metadata.flightData,\n          postponed: metadata.postponed,\n          status: metadata.statusCode,\n          segmentData: metadata.segmentData,\n        } satisfies CachedAppPageValue,\n        cacheControl,\n      } satisfies ResponseCacheEntry\n    }\n\n    const responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry,\n      isRevalidating,\n      span,\n    }) => {\n      const isProduction = routeModule.isDev === false\n      const didRespond = hasResolved || res.writableEnded\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousCacheEntry &&\n        !minimalMode\n      ) {\n        if (routerServerContext?.render404) {\n          await routerServerContext.render404(req, res)\n        } else {\n          res.statusCode = 404\n          res.end('This page could not be found')\n        }\n        return null\n      }\n\n      let fallbackMode: FallbackMode | undefined\n\n      if (prerenderInfo) {\n        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n      }\n\n      // When serving a bot request, we want to serve a blocking render and not\n      // the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (previousCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (\n        !minimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        ssgCacheKey &&\n        !didRespond &&\n        !isDraftMode &&\n        pageIsDynamic &&\n        (isProduction || !isPrerendered)\n      ) {\n        let fallbackResponse: ResponseCacheEntry | null | undefined\n\n        if (isRoutePPREnabled && !isRSCRequest) {\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          fallbackResponse = await routeModule.handleResponse({\n            cacheKey: isProduction ? normalizedSrcPage : null,\n            req,\n            nextConfig,\n            routeKind: RouteKind.APP_PAGE,\n            isFallback: true,\n            prerenderManifest,\n            isRoutePPREnabled,\n            responseGenerator: async () =>\n              doRender({\n                span,\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                fallbackRouteParams:\n                  // If we're in production or we're debugging the fallback\n                  // shell then we should postpone when dynamic params are\n                  // accessed.\n                  isProduction || isDebugFallbackShell\n                    ? getFallbackRouteParams(normalizedSrcPage)\n                    : null,\n              }),\n            waitUntil: ctx.waitUntil,\n          })\n\n          // If the fallback response was set to null, then we should return null.\n          if (fallbackResponse === null) return null\n\n          // Otherwise, if we did get a fallback response, we should return it.\n          if (fallbackResponse) {\n            // Remove the cache control from the response to prevent it from being\n            // used in the surrounding cache.\n            delete fallbackResponse.cacheControl\n\n            return fallbackResponse\n          }\n        }\n      }\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      const postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(''),\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      // If this is a dynamic route with PPR enabled and the default route\n      // matches were set, then we should pass the fallback route params to\n      // the renderer as this is a fallback revalidation request.\n      const fallbackRouteParams =\n        pageIsDynamic &&\n        isRoutePPREnabled &&\n        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n          ? getFallbackRouteParams(pathname)\n          : null\n\n      // Perform the render.\n      return doRender({\n        span,\n        postponed,\n        fallbackRouteParams,\n      })\n    }\n\n    const handleResponse = async (span?: Span): Promise<null | void> => {\n      const cacheEntry = await routeModule.handleResponse({\n        cacheKey: ssgCacheKey,\n        responseGenerator: (c) =>\n          responseGenerator({\n            span,\n            ...c,\n          }),\n        routeKind: RouteKind.APP_PAGE,\n        isOnDemandRevalidate,\n        isRoutePPREnabled,\n        req,\n        nextConfig,\n        prerenderManifest,\n        waitUntil: ctx.waitUntil,\n      })\n\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      // In dev, we should not cache pages for any reason.\n      if (routeModule.isDev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n\n      if (!cacheEntry) {\n        if (ssgCacheKey) {\n          // A cache entry might not be generated if a response is written\n          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n          // have a cache key. If we do have a cache key but we don't end up\n          // with a cache entry, then either Next.js or the application has a\n          // bug that needs fixing.\n          throw new Error('invariant: cache entry required but not generated')\n        }\n        return null\n      }\n\n      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n        throw new Error(\n          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n        )\n      }\n\n      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n\n      if (\n        isSSG &&\n        // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest &&\n        (!didPostpone || isPrefetchRSCRequest)\n      ) {\n        if (!minimalMode) {\n          // set x-nextjs-cache header to match the header\n          // we set for the image-optimizer\n          res.setHeader(\n            'x-nextjs-cache',\n            isOnDemandRevalidate\n              ? 'REVALIDATED'\n              : cacheEntry.isMiss\n                ? 'MISS'\n                : cacheEntry.isStale\n                  ? 'STALE'\n                  : 'HIT'\n          )\n        }\n        // Set a header used by the client router to signal the response is static\n        // and should respect the `static` cache staleTime value.\n        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n      }\n      const { value: cachedData } = cacheEntry\n\n      // Coerce the cache control parameter from the render.\n      let cacheControl: CacheControl | undefined\n\n      // If this is a resume request in minimal mode it is streamed with dynamic\n      // content and should not be cached.\n      if (minimalPostponed) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this is in minimal mode and this is a flight request that isn't a\n      // prefetch request while PPR is enabled, it cannot be cached as it contains\n      // dynamic content.\n      else if (\n        minimalMode &&\n        isRSCRequest &&\n        !isPrefetchRSCRequest &&\n        isRoutePPREnabled\n      ) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (!routeModule.isDev) {\n        // If this is a preview mode request, we shouldn't cache it\n        if (isDraftMode) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n\n        // If this isn't SSG, then we should set change the header only if it is\n        // not set already.\n        else if (!isSSG) {\n          if (!res.getHeader('Cache-Control')) {\n            cacheControl = { revalidate: 0, expire: undefined }\n          }\n        } else if (cacheEntry.cacheControl) {\n          // If the cache entry has a cache control with a revalidate value that's\n          // a number, use it.\n          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n            if (cacheEntry.cacheControl.revalidate < 1) {\n              throw new Error(\n                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n              )\n            }\n\n            cacheControl = {\n              revalidate: cacheEntry.cacheControl.revalidate,\n              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n            }\n          }\n          // Otherwise if the revalidate value is false, then we should use the\n          // cache time of one year.\n          else {\n            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n          }\n        }\n      }\n\n      cacheEntry.cacheControl = cacheControl\n\n      if (\n        typeof segmentPrefetchHeader === 'string' &&\n        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n        cachedData.segmentData\n      ) {\n        // This is a prefetch request issued by the client Segment Cache. These\n        // should never reach the application layer (lambda). We should either\n        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n        // Set a header to indicate that PPR is enabled for this route. This\n        // lets the client distinguish between a regular cache miss and a cache\n        // miss due to PPR being disabled. In other contexts this header is used\n        // to indicate that the response contains dynamic data, but here we're\n        // only using it to indicate that the feature is enabled â€” the segment\n        // response itself contains whether the data is dynamic.\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n        // Add the cache tags header to the response if it exists and we're in\n        // minimal mode while rendering a static page.\n        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n        if (minimalMode && isSSG && tags && typeof tags === 'string') {\n          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n        }\n\n        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n        if (matchedSegment !== undefined) {\n          // Cache hit\n          return sendRenderResult({\n            req,\n            res,\n            type: 'rsc',\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: RenderResult.fromStatic(matchedSegment),\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // Cache miss. Either a cache entry for this route has not been generated\n        // (which technically should not be possible when PPR is enabled, because\n        // at a minimum there should always be a fallback entry) or there's no\n        // match for the requested segment. Respond with a 204 No Content. We\n        // don't bother to respond with 404, because these requests are only\n        // issued as part of a prefetch.\n        res.statusCode = 204\n        return sendRenderResult({\n          req,\n          res,\n          type: 'rsc',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(''),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If there's a callback for `onCacheEntry`, call it with the cache entry\n      // and the revalidate options.\n      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n      if (onCacheEntry) {\n        const finished = await onCacheEntry(\n          {\n            ...cacheEntry,\n            // TODO: remove this when upstream doesn't\n            // always expect this value to be \"PAGE\"\n            value: {\n              ...cacheEntry.value,\n              kind: 'PAGE',\n            },\n          },\n          {\n            url: getRequestMeta(req, 'initURL'),\n          }\n        )\n        if (finished) {\n          // TODO: maybe we have to end the request?\n          return null\n        }\n      }\n\n      // If the request has a postponed state and it's a resume request we\n      // should error.\n      if (didPostpone && minimalPostponed) {\n        throw new Error(\n          'Invariant: postponed state should not be present on a resume request'\n        )\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!minimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (minimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n      if (\n        !minimalMode &&\n        cachedData.status &&\n        RedirectStatusCode[cachedData.status] &&\n        isRSCRequest\n      ) {\n        res.statusCode = 200\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isDraftMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          if (cachedData.postponed) {\n            throw new Error('Invariant: Expected postponed to be undefined')\n          }\n\n          return sendRenderResult({\n            req,\n            res,\n            type: 'rsc',\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: cachedData.html,\n            // Dynamic RSC responses cannot be cached, even if they're\n            // configured with `force-static` because we have no way of\n            // distinguishing between `force-static` and pages that have no\n            // postponed state.\n            // TODO: distinguish `force-static` from pages with no postponed state (static)\n            cacheControl: isDynamicRSCRequest\n              ? { revalidate: 0, expire: undefined }\n              : cacheEntry.cacheControl,\n          })\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return sendRenderResult({\n          req,\n          res,\n          type: 'rsc',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(cachedData.rscData),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // This is a request for HTML data.\n      let body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || minimalMode) {\n        return sendRenderResult({\n          req,\n          res,\n          type: 'html',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.chain(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return sendRenderResult({\n          req,\n          res,\n          type: 'html',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        })\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.chain(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        span,\n        postponed: cachedData.postponed,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return sendRenderResult({\n        req,\n        res,\n        type: 'html',\n        generateEtags: nextConfig.generateEtags,\n        poweredByHeader: nextConfig.poweredByHeader,\n        result: body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      })\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      return await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${req.url}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    // if we aren't wrapped by base-server handle here\n    if (!activeSpan) {\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: srcPage,\n          routeType: 'render',\n          revalidateReason: getRevalidateReason({\n            isRevalidate: isSSG,\n            isOnDemandRevalidate,\n          }),\n        },\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n    throw err\n  }\n}\n"],"names":["AppPageRouteModule","RouteKind","getRevalidateReason","getTracer","SpanKind","getRequestMeta","BaseServerSpan","interopDefault","NodeNextRequest","NodeNextResponse","checkIsAppPPREnabled","getFallbackRouteParams","setReferenceManifestsSingleton","isHtmlBotRequest","shouldServeStreamingMetadata","createServerModuleMap","normalizeAppPath","getIsPossibleServerAction","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_DID_POSTPONE_HEADER","getBotType","isBot","CachedRouteKind","decodePathParams","FallbackMode","parseFallbackField","RenderResult","CACHE_ONE_YEAR","NEXT_CACHE_TAGS_HEADER","ENCODED_TAGS","sendRenderResult","NoFallbackError","tree","pages","GlobalError","__next_app__","require","__next_app_require__","loadChunk","__next_app_load_chunk__","entryBase","RedirectStatusCode","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","projectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","prerenderManifest","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","initialPostponed","minimalMode","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","query","params","parsedUrl","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","isDraftMode","revalidateOnlyGenerated","routerServerContext","nextConfig","normalizedSrcPage","isOnDemandRevalidate","resolvedPathname","prerenderInfo","dynamicRoutes","isPrerendered","routes","isSSG","Boolean","fallback","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","experimental","ppr","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","renderingMode","isDev","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","undefined","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","ComponentMod","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","invokeRouteModule","span","context","nextReq","nextRes","NODE_ENV","dynamicIO","renderOpts","warmup","metadata","renderResumeDataCache","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","url","doRender","postponed","fallbackRouteParams","sharedContext","serverComponentsHmrCache","App","Document","pageConfig","Component","setIsrStatus","dir","isRevalidate","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","previewProps","preview","deploymentId","enableTainting","taint","devtoolSegmentExplorer","reactMaxHeadersLength","incrementalCache","cacheLifeProfiles","cacheLife","basePath","serverActions","nextExport","isStaticGeneration","expireTime","staleTimes","clientSegmentCache","dynamicOnHover","inlineCss","authInterrupts","clientTraceMetadata","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","onRequestError","err","dev","result","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","Error","description","stack","message","substring","indexOf","value","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","render404","fallbackMode","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","fallbackResponse","handleResponse","cacheKey","routeKind","isFallback","expire","PAGES","fromStatic","pageData","cacheEntry","cachedData","c","setHeader","didPostpone","isMiss","getHeader","tags","matchedSegment","type","generateEtags","poweredByHeader","onCacheEntry","finished","key","Object","entries","Array","isArray","v","appendHeader","toString","body","chain","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason"],"mappings":"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","ignoreList":[0]}