{"version":3,"sources":["turbopack:///[project]/docs-fuma/node_modules/next/dist/src/build/templates/app-page.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport {\n  AppPageRouteModule,\n  type AppPageRouteHandlerContext,\n} from '../../server/route-modules/app-page/module.compiled' with { 'turbopack-transition': 'next-ssr' }\n\nimport { RouteKind } from '../../server/route-kind' with { 'turbopack-transition': 'next-server-utility' }\n\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\nimport { getRequestMeta } from '../../server/request-meta'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { interopDefault } from '../../server/app-render/interop-default'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\nimport {\n  getFallbackRouteParams,\n  type FallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport {\n  isHtmlBotRequest,\n  shouldServeStreamingMetadata,\n} from '../../server/lib/streaming-metadata'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n} from '../../client/components/app-router-headers'\nimport { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\nimport {\n  CachedRouteKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\nimport { decodePathParams } from '../../server/lib/router-utils/decode-path-params'\nimport { FallbackMode, parseFallbackField } from '../../lib/fallback'\nimport RenderResult from '../../server/render-result'\nimport { CACHE_ONE_YEAR, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport type { CacheControl } from '../../server/lib/cache-control'\nimport { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\nimport { sendRenderResult } from '../../server/send-payload'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\n\n// These are injected by the loader afterwards.\n\n/**\n * The tree created in next-app-loader that holds component segments and modules\n * and I've updated it.\n */\ndeclare const tree: LoaderTree\ndeclare const pages: any\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\n// INJECT:tree\n// INJECT:pages\n\nexport { tree, pages }\n\nimport GlobalError from 'VAR_MODULE_GLOBAL_ERROR' with { 'turbopack-transition': 'next-server-utility' }\n\nexport { GlobalError }\n\n// These are injected by the loader afterwards.\ndeclare const __next_app_require__: (id: string | number) => unknown\ndeclare const __next_app_load_chunk__: (id: string | number) => Promise<unknown>\n\n// INJECT:__next_app_require__\n// INJECT:__next_app_load_chunk__\n\nexport const __next_app__ = {\n  require: __next_app_require__,\n  loadChunk: __next_app_load_chunk__,\n}\n\nimport * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\n\nexport * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n  definition: {\n    kind: RouteKind.APP_PAGE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n    appPaths: [],\n  },\n  userland: {\n    loaderTree: tree,\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const initialPostponed = getRequestMeta(req, 'postponed')\n  // TODO: replace with more specific flags\n  const minimalMode = getRequestMeta(req, 'minimalMode')\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    query,\n    params,\n    parsedUrl,\n    pageIsDynamic,\n    buildManifest,\n    nextFontManifest,\n    reactLoadableManifest,\n    serverActionsManifest,\n    clientReferenceManifest,\n    subresourceIntegrityManifest,\n    prerenderManifest,\n    isDraftMode,\n\n    revalidateOnlyGenerated,\n    routerServerContext,\n    nextConfig,\n  } = prepareResult\n\n  const pathname = parsedUrl.pathname || '/'\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let { isOnDemandRevalidate } = prepareResult\n\n  // TODO: rework this to not be necessary as a middleware\n  // rewrite should not need to pass this context like this\n  // maybe we rely on rewrite header instead\n  let resolvedPathname = getRequestMeta(req, 'rewroteURL') || pathname\n\n  if (resolvedPathname === '/index') {\n    resolvedPathname = '/'\n  }\n  resolvedPathname = decodePathParams(resolvedPathname)\n\n  const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n  const isPrerendered = prerenderManifest.routes[resolvedPathname]\n\n  let isSSG = Boolean(\n    prerenderInfo ||\n      isPrerendered ||\n      prerenderManifest.routes[normalizedSrcPage]\n  )\n\n  // if the page is dynamicParams: false and this pathname wasn't prerender\n  // trigger the no fallback handling\n  if (isSSG && prerenderInfo?.fallback === false && !isPrerendered) {\n    throw new NoFallbackError()\n  }\n\n  const userAgent = req.headers['user-agent'] || ''\n  const botType = getBotType(userAgent)\n  const isHtmlBot = isHtmlBotRequest(req)\n\n  /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */\n  const isPrefetchRSCRequest =\n    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n    Boolean(req.headers[NEXT_ROUTER_PREFETCH_HEADER])\n\n  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n  const isRSCRequest =\n    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n\n  const isPossibleServerAction = getIsPossibleServerAction(req)\n\n  /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */\n  const couldSupportPPR: boolean = checkIsAppPPREnabled(\n    nextConfig.experimental.ppr\n  )\n\n  // When enabled, this will allow the use of the `?__nextppronly` query to\n  // enable debugging of the static shell.\n  const hasDebugStaticShellQuery =\n    process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n    typeof query.__nextppronly !== 'undefined' &&\n    couldSupportPPR\n\n  // When enabled, this will allow the use of the `?__nextppronly` query\n  // to enable debugging of the fallback shell.\n  const hasDebugFallbackShellQuery =\n    hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n  // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n  // prerender manifest and this is an app page.\n  const isRoutePPREnabled: boolean =\n    couldSupportPPR &&\n    ((\n      prerenderManifest.routes[normalizedSrcPage] ??\n      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n    )?.renderingMode === 'PARTIALLY_STATIC' ||\n      // Ideally we'd want to check the appConfig to see if this page has PPR\n      // enabled or not, but that would require plumbing the appConfig through\n      // to the server during development. We assume that the page supports it\n      // but only during development.\n      (hasDebugStaticShellQuery &&\n        (routeModule.isDev === true ||\n          routerServerContext?.experimentalTestProxy === true)))\n\n  const isDebugStaticShell: boolean =\n    hasDebugStaticShellQuery && isRoutePPREnabled\n\n  // We should enable debugging dynamic accesses when the static shell\n  // debugging has been enabled and we're also in development mode.\n  const isDebugDynamicAccesses =\n    isDebugStaticShell && routeModule.isDev === true\n\n  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n  // If we're in minimal mode, then try to get the postponed information from\n  // the request metadata. If available, use it for resuming the postponed\n  // render.\n  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n\n  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n  // we can use this fact to only generate the flight data for the request\n  // because we can't cache the HTML (as it's also dynamic).\n  const isDynamicRSCRequest =\n    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n  // Need to read this before it's stripped by stripFlightHeaders. We don't\n  // need to transfer it to the request meta because it's only read\n  // within this function; the static segment data should have already been\n  // generated, so we will always either return a static response or a 404.\n  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n  // being true for a revalidate due to modifying the base-server this.renderOpts\n  // when fixing this to correct logic it causes hydration issue since we set\n  // serveStreamingMetadata to true during export\n  let serveStreamingMetadata = !userAgent\n    ? true\n    : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n\n  if (isHtmlBot && isRoutePPREnabled) {\n    isSSG = false\n    serveStreamingMetadata = false\n  }\n\n  // In development, we always want to generate dynamic HTML.\n  let supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG ||\n    // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof initialPostponed === 'string' ||\n    // If this is a dynamic RSC request, then this render supports dynamic\n    // HTML (it's dynamic).\n    isDynamicRSCRequest\n\n  // When html bots request PPR page, perform the full dynamic rendering.\n  const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n\n  let ssgCacheKey: string | null = null\n  if (\n    !isDraftMode &&\n    isSSG &&\n    !supportsDynamicResponse &&\n    !isPossibleServerAction &&\n    !minimalPostponed &&\n    !isDynamicRSCRequest\n  ) {\n    ssgCacheKey = resolvedPathname\n  }\n\n  const ComponentMod = {\n    ...entryBase,\n    tree,\n    pages,\n    GlobalError,\n    handler,\n    routeModule,\n    __next_app__,\n  }\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  try {\n    const invokeRouteModule = async (\n      span: Span | undefined,\n      context: AppPageRouteHandlerContext\n    ) => {\n      const nextReq = new NodeNextRequest(req)\n      const nextRes = new NodeNextResponse(res)\n\n      // TODO: adapt for putting the RDC inside the postponed data\n      // If we're in dev, and this isn't a prefetch or a server action,\n      // we should seed the resume data cache.\n      if (process.env.NODE_ENV === 'development') {\n        if (\n          nextConfig.experimental.dynamicIO &&\n          !isPrefetchRSCRequest &&\n          !context.renderOpts.isPossibleServerAction\n        ) {\n          const warmup = await routeModule.warmup(nextReq, nextRes, context)\n\n          // If the warmup is successful, we should use the resume data\n          // cache from the warmup.\n          if (warmup.metadata.renderResumeDataCache) {\n            context.renderOpts.renderResumeDataCache =\n              warmup.metadata.renderResumeDataCache\n          }\n        }\n      }\n\n      return routeModule.render(nextReq, nextRes, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${req.url}`)\n        }\n      })\n    }\n\n    const doRender = async ({\n      span,\n      postponed,\n      fallbackRouteParams,\n    }: {\n      span?: Span\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: FallbackRouteParams | null\n    }): Promise<ResponseCacheEntry> => {\n      const context: AppPageRouteHandlerContext = {\n        query,\n        params,\n        page: normalizedSrcPage,\n        sharedContext: {\n          buildId,\n        },\n        serverComponentsHmrCache: getRequestMeta(\n          req,\n          'serverComponentsHmrCache'\n        ),\n        fallbackRouteParams,\n        renderOpts: {\n          App: () => null,\n          Document: () => null,\n          pageConfig: {},\n          ComponentMod,\n          Component: interopDefault(ComponentMod),\n\n          params,\n          routeModule,\n          page: srcPage,\n          postponed,\n          shouldWaitOnAllReady,\n          serveStreamingMetadata,\n          supportsDynamicResponse:\n            typeof postponed === 'string' || supportsDynamicResponse,\n          buildManifest,\n          nextFontManifest,\n          reactLoadableManifest,\n          subresourceIntegrityManifest,\n          serverActionsManifest,\n          clientReferenceManifest,\n          setIsrStatus: routerServerContext?.setIsrStatus,\n\n          dir: routeModule.projectDir,\n          isDraftMode,\n          isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n          botType,\n          isOnDemandRevalidate,\n          isPossibleServerAction,\n          assetPrefix: nextConfig.assetPrefix,\n          nextConfigOutput: nextConfig.output,\n          crossOrigin: nextConfig.crossOrigin,\n          trailingSlash: nextConfig.trailingSlash,\n          previewProps: prerenderManifest.preview,\n          deploymentId: nextConfig.deploymentId,\n          enableTainting: nextConfig.experimental.taint,\n          htmlLimitedBots: nextConfig.htmlLimitedBots,\n          devtoolSegmentExplorer:\n            nextConfig.experimental.devtoolSegmentExplorer,\n          reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n\n          multiZoneDraftMode,\n          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n          cacheLifeProfiles: nextConfig.experimental.cacheLife,\n          basePath: nextConfig.basePath,\n          serverActions: nextConfig.experimental.serverActions,\n\n          ...(isDebugStaticShell || isDebugDynamicAccesses\n            ? {\n                nextExport: true,\n                supportsDynamicResponse: false,\n                isStaticGeneration: true,\n                isRevalidate: true,\n                isDebugDynamicAccesses: isDebugDynamicAccesses,\n              }\n            : {}),\n\n          experimental: {\n            isRoutePPREnabled,\n            expireTime: nextConfig.expireTime,\n            staleTimes: nextConfig.experimental.staleTimes,\n            dynamicIO: Boolean(nextConfig.experimental.dynamicIO),\n            clientSegmentCache: Boolean(\n              nextConfig.experimental.clientSegmentCache\n            ),\n            dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n            inlineCss: Boolean(nextConfig.experimental.inlineCss),\n            authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n            clientTraceMetadata:\n              nextConfig.experimental.clientTraceMetadata || ([] as any),\n          },\n\n          waitUntil: ctx.waitUntil,\n          onClose: (cb) => {\n            res.on('close', cb)\n          },\n          onAfterTaskError: () => {},\n\n          onInstrumentationRequestError: (error, _request, errorContext) =>\n            routeModule.onRequestError(\n              req,\n              error,\n              errorContext,\n              routerServerContext\n            ),\n          err: getRequestMeta(req, 'invokeError'),\n          dev: routeModule.isDev,\n        },\n      }\n\n      const result = await invokeRouteModule(span, context)\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = metadata.fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !routeModule.isDev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.APP_PAGE,\n          html: result,\n          headers,\n          rscData: metadata.flightData,\n          postponed: metadata.postponed,\n          status: metadata.statusCode,\n          segmentData: metadata.segmentData,\n        } satisfies CachedAppPageValue,\n        cacheControl,\n      } satisfies ResponseCacheEntry\n    }\n\n    const responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry,\n      isRevalidating,\n      span,\n    }) => {\n      const isProduction = routeModule.isDev === false\n      const didRespond = hasResolved || res.writableEnded\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousCacheEntry &&\n        !minimalMode\n      ) {\n        if (routerServerContext?.render404) {\n          await routerServerContext.render404(req, res)\n        } else {\n          res.statusCode = 404\n          res.end('This page could not be found')\n        }\n        return null\n      }\n\n      let fallbackMode: FallbackMode | undefined\n\n      if (prerenderInfo) {\n        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n      }\n\n      // When serving a bot request, we want to serve a blocking render and not\n      // the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (previousCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (\n        !minimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        ssgCacheKey &&\n        !didRespond &&\n        !isDraftMode &&\n        pageIsDynamic &&\n        (isProduction || !isPrerendered)\n      ) {\n        let fallbackResponse: ResponseCacheEntry | null | undefined\n\n        if (isRoutePPREnabled && !isRSCRequest) {\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          fallbackResponse = await routeModule.handleResponse({\n            cacheKey: isProduction ? normalizedSrcPage : null,\n            req,\n            nextConfig,\n            routeKind: RouteKind.APP_PAGE,\n            isFallback: true,\n            prerenderManifest,\n            isRoutePPREnabled,\n            responseGenerator: async () =>\n              doRender({\n                span,\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                fallbackRouteParams:\n                  // If we're in production or we're debugging the fallback\n                  // shell then we should postpone when dynamic params are\n                  // accessed.\n                  isProduction || isDebugFallbackShell\n                    ? getFallbackRouteParams(normalizedSrcPage)\n                    : null,\n              }),\n            waitUntil: ctx.waitUntil,\n          })\n\n          // If the fallback response was set to null, then we should return null.\n          if (fallbackResponse === null) return null\n\n          // Otherwise, if we did get a fallback response, we should return it.\n          if (fallbackResponse) {\n            // Remove the cache control from the response to prevent it from being\n            // used in the surrounding cache.\n            delete fallbackResponse.cacheControl\n\n            return fallbackResponse\n          }\n        }\n      }\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      const postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(''),\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      // If this is a dynamic route with PPR enabled and the default route\n      // matches were set, then we should pass the fallback route params to\n      // the renderer as this is a fallback revalidation request.\n      const fallbackRouteParams =\n        pageIsDynamic &&\n        isRoutePPREnabled &&\n        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n          ? getFallbackRouteParams(pathname)\n          : null\n\n      // Perform the render.\n      return doRender({\n        span,\n        postponed,\n        fallbackRouteParams,\n      })\n    }\n\n    const handleResponse = async (span?: Span): Promise<null | void> => {\n      const cacheEntry = await routeModule.handleResponse({\n        cacheKey: ssgCacheKey,\n        responseGenerator: (c) =>\n          responseGenerator({\n            span,\n            ...c,\n          }),\n        routeKind: RouteKind.APP_PAGE,\n        isOnDemandRevalidate,\n        isRoutePPREnabled,\n        req,\n        nextConfig,\n        prerenderManifest,\n        waitUntil: ctx.waitUntil,\n      })\n\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      // In dev, we should not cache pages for any reason.\n      if (routeModule.isDev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n\n      if (!cacheEntry) {\n        if (ssgCacheKey) {\n          // A cache entry might not be generated if a response is written\n          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n          // have a cache key. If we do have a cache key but we don't end up\n          // with a cache entry, then either Next.js or the application has a\n          // bug that needs fixing.\n          throw new Error('invariant: cache entry required but not generated')\n        }\n        return null\n      }\n\n      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n        throw new Error(\n          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n        )\n      }\n\n      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n\n      if (\n        isSSG &&\n        // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest &&\n        (!didPostpone || isPrefetchRSCRequest)\n      ) {\n        if (!minimalMode) {\n          // set x-nextjs-cache header to match the header\n          // we set for the image-optimizer\n          res.setHeader(\n            'x-nextjs-cache',\n            isOnDemandRevalidate\n              ? 'REVALIDATED'\n              : cacheEntry.isMiss\n                ? 'MISS'\n                : cacheEntry.isStale\n                  ? 'STALE'\n                  : 'HIT'\n          )\n        }\n        // Set a header used by the client router to signal the response is static\n        // and should respect the `static` cache staleTime value.\n        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n      }\n      const { value: cachedData } = cacheEntry\n\n      // Coerce the cache control parameter from the render.\n      let cacheControl: CacheControl | undefined\n\n      // If this is a resume request in minimal mode it is streamed with dynamic\n      // content and should not be cached.\n      if (minimalPostponed) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this is in minimal mode and this is a flight request that isn't a\n      // prefetch request while PPR is enabled, it cannot be cached as it contains\n      // dynamic content.\n      else if (\n        minimalMode &&\n        isRSCRequest &&\n        !isPrefetchRSCRequest &&\n        isRoutePPREnabled\n      ) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (!routeModule.isDev) {\n        // If this is a preview mode request, we shouldn't cache it\n        if (isDraftMode) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n\n        // If this isn't SSG, then we should set change the header only if it is\n        // not set already.\n        else if (!isSSG) {\n          if (!res.getHeader('Cache-Control')) {\n            cacheControl = { revalidate: 0, expire: undefined }\n          }\n        } else if (cacheEntry.cacheControl) {\n          // If the cache entry has a cache control with a revalidate value that's\n          // a number, use it.\n          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n            if (cacheEntry.cacheControl.revalidate < 1) {\n              throw new Error(\n                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n              )\n            }\n\n            cacheControl = {\n              revalidate: cacheEntry.cacheControl.revalidate,\n              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n            }\n          }\n          // Otherwise if the revalidate value is false, then we should use the\n          // cache time of one year.\n          else {\n            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n          }\n        }\n      }\n\n      cacheEntry.cacheControl = cacheControl\n\n      if (\n        typeof segmentPrefetchHeader === 'string' &&\n        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n        cachedData.segmentData\n      ) {\n        // This is a prefetch request issued by the client Segment Cache. These\n        // should never reach the application layer (lambda). We should either\n        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n        // Set a header to indicate that PPR is enabled for this route. This\n        // lets the client distinguish between a regular cache miss and a cache\n        // miss due to PPR being disabled. In other contexts this header is used\n        // to indicate that the response contains dynamic data, but here we're\n        // only using it to indicate that the feature is enabled â€” the segment\n        // response itself contains whether the data is dynamic.\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n        // Add the cache tags header to the response if it exists and we're in\n        // minimal mode while rendering a static page.\n        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n        if (minimalMode && isSSG && tags && typeof tags === 'string') {\n          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n        }\n\n        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n        if (matchedSegment !== undefined) {\n          // Cache hit\n          return sendRenderResult({\n            req,\n            res,\n            type: 'rsc',\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: RenderResult.fromStatic(matchedSegment),\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // Cache miss. Either a cache entry for this route has not been generated\n        // (which technically should not be possible when PPR is enabled, because\n        // at a minimum there should always be a fallback entry) or there's no\n        // match for the requested segment. Respond with a 204 No Content. We\n        // don't bother to respond with 404, because these requests are only\n        // issued as part of a prefetch.\n        res.statusCode = 204\n        return sendRenderResult({\n          req,\n          res,\n          type: 'rsc',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(''),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If there's a callback for `onCacheEntry`, call it with the cache entry\n      // and the revalidate options.\n      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n      if (onCacheEntry) {\n        const finished = await onCacheEntry(\n          {\n            ...cacheEntry,\n            // TODO: remove this when upstream doesn't\n            // always expect this value to be \"PAGE\"\n            value: {\n              ...cacheEntry.value,\n              kind: 'PAGE',\n            },\n          },\n          {\n            url: getRequestMeta(req, 'initURL'),\n          }\n        )\n        if (finished) {\n          // TODO: maybe we have to end the request?\n          return null\n        }\n      }\n\n      // If the request has a postponed state and it's a resume request we\n      // should error.\n      if (didPostpone && minimalPostponed) {\n        throw new Error(\n          'Invariant: postponed state should not be present on a resume request'\n        )\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!minimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (minimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n      if (\n        !minimalMode &&\n        cachedData.status &&\n        RedirectStatusCode[cachedData.status] &&\n        isRSCRequest\n      ) {\n        res.statusCode = 200\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isDraftMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          if (cachedData.postponed) {\n            throw new Error('Invariant: Expected postponed to be undefined')\n          }\n\n          return sendRenderResult({\n            req,\n            res,\n            type: 'rsc',\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: cachedData.html,\n            // Dynamic RSC responses cannot be cached, even if they're\n            // configured with `force-static` because we have no way of\n            // distinguishing between `force-static` and pages that have no\n            // postponed state.\n            // TODO: distinguish `force-static` from pages with no postponed state (static)\n            cacheControl: isDynamicRSCRequest\n              ? { revalidate: 0, expire: undefined }\n              : cacheEntry.cacheControl,\n          })\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return sendRenderResult({\n          req,\n          res,\n          type: 'rsc',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(cachedData.rscData),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // This is a request for HTML data.\n      let body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || minimalMode) {\n        return sendRenderResult({\n          req,\n          res,\n          type: 'html',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.chain(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return sendRenderResult({\n          req,\n          res,\n          type: 'html',\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        })\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.chain(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        span,\n        postponed: cachedData.postponed,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return sendRenderResult({\n        req,\n        res,\n        type: 'html',\n        generateEtags: nextConfig.generateEtags,\n        poweredByHeader: nextConfig.poweredByHeader,\n        result: body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      })\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      return await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${req.url}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    // if we aren't wrapped by base-server handle here\n    if (!activeSpan) {\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: srcPage,\n          routeType: 'render',\n          revalidateReason: getRevalidateReason({\n            isRevalidate: isSSG,\n            isOnDemandRevalidate,\n          }),\n        },\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n    throw err\n  }\n}\n"],"names":["AppPageRouteModule","RouteKind","getRevalidateReason","getTracer","SpanKind","getRequestMeta","BaseServerSpan","interopDefault","NodeNextRequest","NodeNextResponse","checkIsAppPPREnabled","getFallbackRouteParams","setReferenceManifestsSingleton","isHtmlBotRequest","shouldServeStreamingMetadata","createServerModuleMap","normalizeAppPath","getIsPossibleServerAction","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_DID_POSTPONE_HEADER","getBotType","isBot","CachedRouteKind","decodePathParams","FallbackMode","parseFallbackField","RenderResult","CACHE_ONE_YEAR","NEXT_CACHE_TAGS_HEADER","ENCODED_TAGS","sendRenderResult","NoFallbackError","tree","pages","GlobalError","__next_app__","require","__next_app_require__","loadChunk","__next_app_load_chunk__","entryBase","RedirectStatusCode","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","projectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","prerenderManifest","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","initialPostponed","minimalMode","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","query","params","parsedUrl","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","isDraftMode","revalidateOnlyGenerated","routerServerContext","nextConfig","normalizedSrcPage","isOnDemandRevalidate","resolvedPathname","prerenderInfo","dynamicRoutes","isPrerendered","routes","isSSG","Boolean","fallback","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","experimental","ppr","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","renderingMode","isDev","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","undefined","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","ComponentMod","serverModuleMap","method","tracer","activeSpan","getActiveScopeSpan","invokeRouteModule","span","context","nextReq","nextRes","NODE_ENV","dynamicIO","renderOpts","warmup","metadata","renderResumeDataCache","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","url","doRender","postponed","fallbackRouteParams","sharedContext","serverComponentsHmrCache","App","Document","pageConfig","Component","setIsrStatus","dir","isRevalidate","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","previewProps","preview","deploymentId","enableTainting","taint","devtoolSegmentExplorer","reactMaxHeadersLength","incrementalCache","cacheLifeProfiles","cacheLife","basePath","serverActions","nextExport","isStaticGeneration","expireTime","staleTimes","clientSegmentCache","dynamicOnHover","inlineCss","authInterrupts","clientTraceMetadata","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","onRequestError","err","dev","result","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","Error","description","stack","message","substring","indexOf","value","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","render404","fallbackMode","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","fallbackResponse","handleResponse","cacheKey","routeKind","isFallback","expire","PAGES","fromStatic","pageData","cacheEntry","cachedData","c","setHeader","didPostpone","isMiss","getHeader","tags","matchedSegment","type","generateEtags","poweredByHeader","onCacheEntry","finished","key","Object","entries","Array","isArray","v","appendHeader","toString","body","chain","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason"],"mappings":"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","ignoreList":[0]}